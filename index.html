<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Chromatic Circle</title>
    <style>
        html, body {
            margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #000000; color: #FFFFFF;
        }
        
        #canvas-container {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #controls-wrapper {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .control-section {
            position: absolute;
            background-color: rgba(26, 26, 26, 0.85);
            backdrop-filter: blur(5px);
            border: 1px solid #444;
            border-radius: 8px;
            padding: 5px 10px;
            width: 380px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            touch-action: none; /* Prevents page scroll on touch devices */
        }
        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px;
            cursor: grab;
            user-select: none;
        }
        .section-header.dragging {
             cursor: grabbing;
        }
        .section-header h4 { margin: 0; font-size: 1.1em; }
        .section-header .toggle-vis-btn { background: none; border: none; font-size: 1.5em; color: #ccc; cursor: pointer; padding: 0 5px; }
        .section-content { padding: 10px 5px; display: flex; flex-direction: column; gap: 10px; border-top: 1px solid #333; }
        .section-content.hidden { display: none; }
        .control-group { display: flex; flex-wrap: wrap; justify-content: flex-start; align-items: center; gap: 8px 12px; }
        
        #edo-section { border-color: #FFFFFF; }
        #ji-section { border-color: #6495ED; }
        #playback-section { border-color: #888; }
        #scale-section { border-color: #28a745; }
        #chord-section { border-color: #ff4136; }
        
        label { font-weight: bold; }
        select, input, button {
            background-color: #333; color: #fff; border: 1px solid #555;
            padding: 8px 12px; border-radius: 4px; font-size: 1em; cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s, color 0.2s;
            vertical-align: middle;
        }
        input[type="number"] { width: 60px; }
        input[type="search"] { flex-grow: 1; }
        input[type="range"] { padding: 0; cursor: grab; flex-grow: 1; }
        select:hover, input:hover, button:hover:not(:disabled) { background-color: #444; border-color: #777; }
        button:disabled, select:disabled, input:disabled { background-color: #222; color: #666; border-color: #444; cursor: not-allowed; }
        .play-mode-active { background-color: #00C853; border-color: #00e676; }
        
        #chromaticCircleCanvas.play-mode { cursor: pointer; }
        
        #animation-controls {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 50;
            display: none; flex-direction: column; align-items: center; gap: 10px;
        }
        #animation-controls .button-group { display: flex; gap: 15px; }
        .instructions { color: #aaa; font-style: italic; text-align: center; }

        #scale-info-display {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 600px;
            max-height: 25vh;
            overflow-y: auto;
            background-color: rgba(26, 26, 26, 0.9);
            border: 1px solid #9c27b0;
            border-radius: 8px;
            padding: 15px;
            z-index: 90;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            font-size: 0.9em;
        }
        #scale-info-display.hidden { display: none; }
        #scale-info-display h4 { margin: 0 0 10px 0; color: #fff; }
        #scale-info-display p { margin: 0 0 8px 0; color: #ccc; }
        #scale-info-display strong { color: #fff; }
        #scale-info-display ul { list-style: none; padding: 0; margin: 0; }
        #scale-info-display li { padding: 2px 0; }
    </style>
</head>
<body>

    <div id="canvas-container"><canvas id="chromaticCircleCanvas"></canvas></div>

    <div id="controls-wrapper">
        <div class="control-section" id="edo-section" style="top: 0; left: 0;">
            <div class="section-header"><h4>EDO Settings</h4><button class="toggle-vis-btn">⠿</button></div>
            <div class="section-content"><div class="control-group"><label for="base-freq-input">Base Hz:</label> <input type="number" id="base-freq-input" value="110" min="1"><label for="edo-input">EDO:</label> <input type="number" id="edo-input" value="12" min="1" max="360"><button id="show-edo-freqs-btn">EDO Freqs</button></div><div class="control-group"><label for="edo-zoom-slider">EDO Zoom:</label> <input type="range" id="edo-zoom-slider" min="0.5" max="2" step="0.01" value="1"></div></div>
        </div>

        <div class="control-section" id="ji-section" style="top: 150px; left: 0;">
            <div class="section-header"><h4>Just Intonation</h4><button class="toggle-vis-btn">⠿</button></div>
            <div class="section-content"><div class="control-group"><button id="toggle-ratios-btn">JI Ratios</button><button id="show-ji-freqs-btn">JI Freqs</button><button id="toggle-names-btn">Names</button><button id="animate-btn">Animate JI</button></div><div class="control-group"><button id="draw-32-btn" disabled>Draw 3/2</button><button id="reset-ji-path-btn" disabled>Reset JI</button><label for="ji-zoom-slider">JI Zoom:</label> <input type="range" id="ji-zoom-slider" min="0.5" max="2" step="0.01" value="1"></div></div>
        </div>
        
        <div class="control-section" id="playback-section" style="top: 315px; left: 0;">
             <div class="section-header"><h4>Playback & Intervals</h4><button class="toggle-vis-btn">⠿</button></div>
            <div class="section-content"><div class="control-group"><label for="interval-select">Interval:</label> <select id="interval-select" disabled></select><button id="add-interval-btn" disabled>Add</button><button id="reset-edo-path-btn">Reset Path</button></div><div class="control-group"><button id="roll-left-btn">Roll Left</button><button id="roll-right-btn">Roll Right</button></div><div class="control-group"><button id="play-mode-btn">Play Mode</button><button id="play-chord-btn" disabled>Play Chord</button><button id="play-scale-btn" disabled>Play Scale</button></div><div class="control-group"><label for="volume-slider">Volume:</label><input type="range" id="volume-slider" min="0" max="1" step="0.01" value="0.5"></div></div>
        </div>

        <div class="control-section" id="scale-section" style="top: 0px; left: 400px;">
             <div class="section-header"><h4>Scale Library</h4><button class="toggle-vis-btn">⠿</button></div>
            <div class="section-content">
                <div class="control-group"><label for="scale-search">Search:</label><input type="search" id="scale-search" placeholder="Search by name, steps, alias..."></div>
                <div class="control-group"><label for="scale-select">Scales:</label><select id="scale-select" style="width: 100%"></select></div>
                <div class="control-group">
                    <button id="roll-scale-left-btn">Roll Left</button>
                    <button id="roll-scale-right-btn">Roll Right</button>
                    <button id="play-library-scale-btn">Play Scale</button>
                    <button id="scale-info-btn">Scale Info</button>
                </div>
            </div>
        </div>

        <div class="control-section" id="chord-section" style="top: 175px; left: 400px;">
             <div class="section-header"><h4>Chord Library</h4><button class="toggle-vis-btn">⠿</button></div>
            <div class="section-content">
                <div class="control-group"><label for="chord-search">Search:</label><input type="search" id="chord-search" placeholder="Search by name, steps..."></div>
                <div class="control-group"><label for="chord-select">Chords:</label><select id="chord-select" style="width: 100%"></select></div>
                <div class="control-group">
                    <button id="roll-chord-left-btn">Roll Left</button>
                    <button id="roll-chord-right-btn">Roll Right</button>
                    <button id="play-library-chord-btn">Play Chord</button>
                </div>
            </div>
        </div>
    </div>

    <div id="animation-controls">
        <p id="instructions" class="instructions">Animating...</p>
        <div class="button-group"><button id="pause-play-btn">Pause</button><button id="stop-anim-btn">Stop</button></div>
    </div>

    <div id="scale-info-display" class="hidden"></div>
    
    <!-- External library files -->
    <script src="scaleList.js"></script>
    <script src="chordList.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM References ---
            const allFloatingControls = document.querySelectorAll('.control-section input, .control-section button, .control-section select');
            const playModeBtn = document.getElementById('play-mode-btn'), playChordBtn = document.getElementById('play-chord-btn'), playScaleBtn = document.getElementById('play-scale-btn'), draw32Btn = document.getElementById('draw-32-btn');
            const edoInput = document.getElementById('edo-input'), baseFreqInput = document.getElementById('base-freq-input');
            const showEdoFreqsBtn = document.getElementById('show-edo-freqs-btn'), showJiFreqsBtn = document.getElementById('show-ji-freqs-btn');
            const intervalSelect = document.getElementById('interval-select'), addIntervalBtn = document.getElementById('add-interval-btn');
            const resetEdoPathBtn = document.getElementById('reset-edo-path-btn');
            const resetJiPathBtn = document.getElementById('reset-ji-path-btn');
            const rollLeftBtn = document.getElementById('roll-left-btn');
            const rollRightBtn = document.getElementById('roll-right-btn');
            const toggleRatiosBtn = document.getElementById('toggle-ratios-btn'), toggleNamesBtn = document.getElementById('toggle-names-btn');
            const animateBtn = document.getElementById('animate-btn');
            const edoZoomSlider = document.getElementById('edo-zoom-slider'), jiZoomSlider = document.getElementById('ji-zoom-slider'), volumeSlider = document.getElementById('volume-slider');
            const instructions = document.getElementById('instructions');
            const canvas = document.getElementById('chromaticCircleCanvas'), ctx = canvas.getContext('2d');
            const animationControls = document.getElementById('animation-controls');
            const pausePlayBtn = document.getElementById('pause-play-btn');
            const stopAnimBtn = document.getElementById('stop-anim-btn');
            const scaleSearchInput = document.getElementById('scale-search'), scaleSelect = document.getElementById('scale-select');
            const rollScaleLeftBtn = document.getElementById('roll-scale-left-btn'), rollScaleRightBtn = document.getElementById('roll-scale-right-btn');
            const playLibraryScaleBtn = document.getElementById('play-library-scale-btn'), scaleInfoBtn = document.getElementById('scale-info-btn'), scaleInfoDisplay = document.getElementById('scale-info-display');
            const chordSearchInput = document.getElementById('chord-search'), chordSelect = document.getElementById('chord-select');
            const rollChordLeftBtn = document.getElementById('roll-chord-left-btn'), rollChordRightBtn = document.getElementById('roll-chord-right-btn'), playLibraryChordBtn = document.getElementById('play-library-chord-btn');

            // --- State Variables ---
            let edo = 12, rootNoteIndex = null, currentNoteIndex = null, edoZoom = 1, jiZoom = 1, baseFrequency = 110, masterVolume = 0.5;
            let edoNotes = [], jiNotes = [], path = [], jiPath = [];
            let selectedScaleSteps = null, selectedScalePath = [], scaleStartNote = 0, scaleModeNames = [];
            let selectedChordSteps = null, selectedChordPath = [], chordStartNote = 0, chordIntervalNames = [];
            let isAnimating = false, isPlayMode = false, isAudioInitialized = false, isPlayingScale = false;
            let showRatios = false, showIntervalNames = false, showEdoFreqs = false, showJiFreqs = false, showScaleInfo = false;
            let audioContext, audioBuffer = null, masterGainNode;
            let animationFrameId = null, isPaused = false, startTime = 0, pausedTime = 0;
            
            // --- Libraries & Constants ---
            // Base libraries are defined, then extended with external files.
            let scaleLibrary = [ { edo: 12, name: 'Ionian (Major)', steps: [2, 2, 1, 2, 2, 2, 1], aliases: ['G.Lydian', 'M.Hypolydian', 'Major', 'Bilaval That', 'Mela Shankarabharanam', 'Raga Atana', 'Begada', 'Kathanakuthuhalam', 'Ghana Heptatonic', 'Peruvian Major', 'Matzore', 'Rast ascending: Greece', '4th plagal Byzantine', 'Ararai: Ethiopia', 'Makam Cargah', 'Ajam Ashiran', 'Dastgah-e Mahur', 'Dastgah-e Rast Panjgah', 'Xin: China', 'DS2', 'Heptatonia prima'] }, { edo: 12, name: 'Dorian', steps: [2, 1, 2, 2, 2, 1, 2], aliases: ['M.Dorian', 'G.Phrygian', 'M.Hypomixolydian', 'G.M.Hypoionian (Hypoiastian)', 'Kafi That', 'Mela Kharaharapriya', 'Raga Bageshri', 'Bhimpalasi', 'Dhanasri', 'Huseni', 'Kanara', 'Kannada Gowlai', 'Kapi', 'Nayaki Kanada', 'Raisa Kanada', 'Ritigaula', 'Shahana', 'Sriraga', 'Mischung 5', 'Gregorian nr.8', 'Eskimo Heptatonic', 'Yu: China', 'Hyojo', 'Oshikicho', 'Banshikicho: Japan', 'Nam: Vietnam'] }, { edo: 12, name: 'Phrygian', steps: [1, 2, 2, 2, 1, 2, 2], aliases: ['M.Phrygian', 'G.Dorian', 'G.M.Hypoaeolian', 'Bhairavi That', 'Mela Hanumatodi', 'Raga Asavari (Asaveri)', 'Bilashkhani Todi', 'Darjeeling', 'Ghanta', 'Makam Kurd', 'Gregorian nr.3', 'Escala Andaluza', 'In', 'Zokuso: Japan', 'Ousak: Greece', 'Major inverse'] }, { edo: 12, name: 'Lydian', steps: [2, 2, 2, 1, 2, 2, 1], aliases: ['M.Lydian', 'G.Hypolydian', 'G.M.Hypolocrian', 'Rut biscale ascending', 'Kalyan That (Yaman)', 'Mela Mecakalyani', 'Raga Chandrakant', 'Malarani', 'Shuddh Kalyan', 'Ping', 'Kung', 'Gu: China'] }, { edo: 12, name: 'Mixolydian', steps: [2, 2, 1, 2, 2, 1, 2], aliases: ['M.Mixolydian', 'G.Hypophrygian', 'G.Ionian (Iastian)', 'G.M.Hypoionian', 'Hypermixolydian', 'Mischung 3', 'Khamaj That', 'Mela Harikambhoji', 'Raga Balahamsa', 'Bhim', 'Devamanohari', 'Gaoti', 'Harini', 'Janjhuti', 'Kaamaai', 'Kalashri', 'Khambhavati', 'Sahana', 'Sakh', 'Surati', 'Gregorian nr.7', 'Enharmonic Byzantine Liturgical', 'Rast descending: Greece', 'Ching', 'Shang: China'] }, { edo: 12, name: 'Aeolian (Natural Minor)', steps: [2, 1, 2, 2, 1, 2, 2], aliases: ['G.M.Aeolian', 'G.M.Hypodorian', 'G.Hyperphrygian', 'Natural Minor', 'Melodic Minor descending', 'Asavari That', 'Mela Natabhairavi', 'Raga Jaunpuri', 'Adana', 'Darbari', 'Dhanyasi', 'Jingla', 'Sampurna Malkauns', 'Gregorian nr.2', 'Makam Buselik', 'Nihavend', 'Peruvian Minor', 'Se', 'Chiao: China', 'Geez', 'Ezel: Ethiopia', 'Kiourdi descending: Greece', 'Cushak: Armenia'] }, { edo: 12, name: 'Locrian', steps: [1, 2, 2, 1, 2, 2, 2], aliases: ['M.Locrian', 'G.Mixolydian', 'G.Hyperdorian', 'M.Hypophrygian', 'G.M.Hyperaeolian', 'Rut biscale descending', 'Pien chih: China', 'Makam Lami', 'Raga Meladalan', 'Yishtabach: Jewish'] }, ];
            let chordLibrary = [ { edo: 12, name: 'Major', steps: [4, 7], aliases: [] }, { edo: 12, name: 'Minor', steps: [3, 7], aliases: [] }, { edo: 24, name: 'Neutral', steps: [7, 14], aliases: [] }, ];

            // Merge external libraries if they exist
            if (typeof scalesList !== 'undefined') { scaleLibrary.push(...scalesList); }
            if (typeof chordList !== 'undefined') { chordLibrary.push(...chordList); }

            const INTERVAL_NAMES_12_EDO = { 0: "R", 1: "m2", 2: "M2", 3: "m3", 4: "M3", 5: "P4", 6: "d5", 7: "P5", 8: "m6", 9: "M6", 10: "m7", 11: "M7"};
            const JI_PERFECT_FIFTH_RADIANS = 210.59 * (Math.PI / 180);
            const JUST_INTONATION_RATIOS = [ { label: '1/1', value: 1/1, name: 'Unison' }, { label: '16/15', value: 16/15, name: 'm2' }, { label: '9/8', value: 9/8, name: 'M2' }, { label: '6/5', value: 6/5, name: 'm3' }, { label: '5/4', value: 5/4, name: 'M3' }, { label: '4/3', value: 4/3, name: 'P4' }, { label: '45/32', value: 45/32, name: 'Tritone' }, { label: '3/2', value: 3/2, name: 'P5' }, { label: '8/5', value: 8/5, name: 'm6' }, { label: '5/3', value: 5/3, name: 'M6' }, { label: '9/5', value: 9/5, name: 'm7' }, { label: '15/8', value: 15/8, name: 'M7' } ].sort((a, b) => a.value - b.value);
            const ANIMATION_STAGES = [ { name: 'UNROLL', duration: 2000 }, { name: 'SHOW_ROOT', duration: 4500 }, { name: 'SHOW_OCTAVE', duration: 4500 }, { name: 'SHOW_THIRD_HARMONIC', duration: 4500 }, { name: 'SHOW_PERFECT_FIFTH', duration: 5000 }, { name: 'SHOW_PERFECT_FOURTH', duration: 5000 }, { name: 'SHOW_FOURTH_HARMONIC', duration: 4500 }, { name: 'SHOW_MAJOR_THIRD', duration: 5000 }, { name: 'SHOW_MINOR_THIRD', duration: 5000 }, { name: 'SHOW_DERIVED_M2', duration: 5000 }, { name: 'SHOW_DERIVED_M6', duration: 4000 }, { name: 'SHOW_DERIVED_m2', duration: 4000 }, { name: 'SHOW_DERIVED_M7', duration: 4000 }, { name: 'SHOW_DERIVED_TRITONE', duration: 5000 }, { name: 'SHOW_DERIVED_m6', duration: 4000 }, { name: 'SHOW_DERIVED_m7', duration: 4000 }, { name: 'CLEAR_HIGHLIGHTS', duration: 1000 }, { name: 'ROLL_BACK', duration: 2000 }, { name: 'FADE_IN_EDO', duration: 1000 }, ];
            const TOTAL_ANIMATION_DURATION = ANIMATION_STAGES.reduce((sum, s) => sum + s.duration, 0);

            // --- App Logic Functions ---
            function resizeAndRecalculate() { const canvasSize = Math.min(window.innerWidth, window.innerHeight); canvas.width = canvasSize; canvas.height = canvasSize; centerX = canvas.width / 2; centerY = canvas.height / 2; baseCircleRadius = canvas.width * 0.22; updateAllRadii(); }
            function updateAllRadii() { circleRadius = baseCircleRadius * edoZoom; edoFreqLabelRadius = circleRadius * 1.30; ratioLabelRadius = circleRadius * 1.60 * jiZoom; jiFreqLabelRadius = circleRadius * 1.90 * jiZoom; nameLabelRadius = circleRadius * 2.20 * jiZoom; let scaleNameRadius = circleRadius * 1.45; noteRadius = Math.max(9, canvas.width / 50); }
            function setup() { isAnimating = false; showScaleInfo = false; let newEdo = parseInt(edoInput.value, 10); if (isNaN(newEdo) || newEdo < 1) newEdo = 12; if (newEdo > 360) newEdo = 360; edoInput.value = newEdo; edo = newEdo; let newFreq = parseFloat(baseFreqInput.value); if (isNaN(newFreq) || newFreq <= 0) newFreq = 110; baseFreqInput.value = newFreq; baseFrequency = newFreq; rootNoteIndex = currentNoteIndex = null; path = []; jiPath = []; selectedScaleSteps = null; selectedScalePath = []; selectedChordSteps = null; selectedChordPath = []; populateScaleSelect(); populateChordSelect(); resizeAndRecalculate(); generateAllNotes(); updateControls(); updateScaleInfoDisplay(); draw(); }
            function setDefaultRootNote() { if (isAnimating || isPlayMode) return; rootNoteIndex = currentNoteIndex = 0; path = [0]; jiPath = []; updateControls(); draw(); }
            function resetEdoPath() { if (rootNoteIndex !== null) { path = [rootNoteIndex]; currentNoteIndex = rootNoteIndex; } detectUserScale(); updateControls(); draw(); }
            function resetJiPath() { jiPath = []; updateControls(); draw(); }
            function rollPath(direction) { if (currentNoteIndex === null || isAnimating || isPlayMode) return; path = path.map(noteIndex => (noteIndex + direction + edo) % edo); rootNoteIndex = path[0]; currentNoteIndex = path[path.length - 1]; detectUserScale(); updateControls(); draw(); }
            function generateAllNotes() { generateEDONotes(); generateJINotes(); }
            function generateEDONotes() { edoNotes = Array.from({ length: edo }, (_, i) => { const angle = (i / edo) * 2 * Math.PI - Math.PI / 2; const freq = baseFrequency * Math.pow(2, i / edo); return { x: centerX + circleRadius * Math.cos(angle), y: centerY + circleRadius * Math.sin(angle), angle: angle, freqX: centerX + edoFreqLabelRadius * Math.cos(angle), freqY: centerY + edoFreqLabelRadius * Math.sin(angle), label: i, frequency: freq, hitRadius: noteRadius }; }); }
            function generateJINotes() { jiNotes = JUST_INTONATION_RATIOS.map(ratio => { const cents = 1200 * Math.log2(ratio.value); const angle = (cents / 1200) * 2 * Math.PI - Math.PI / 2; const freq = baseFrequency * ratio.value; return { ratioX: centerX + ratioLabelRadius * Math.cos(angle), ratioY: centerY + ratioLabelRadius * Math.sin(angle), freqX: centerX + jiFreqLabelRadius * Math.cos(angle), freqY: centerY + jiFreqLabelRadius * Math.sin(angle), nameX: centerX + nameLabelRadius * Math.cos(angle), nameY: centerY + nameLabelRadius * Math.sin(angle), label: ratio.label, name: ratio.name, cents, frequency: freq, hitRadius: 15 }; }); }
            function draw() { ctx.clearRect(0, 0, canvas.width, canvas.height); drawMainCircle(); if (showEdoFreqs) drawEdoFrequencies(); if (showRatios) drawRatios(); if (showJiFreqs) drawJiFrequencies(); if (showIntervalNames) drawIntervalNames(); drawScalePath(); drawChordPath(); drawConnectingLines(); drawJiPath(); drawEDONotes(); drawScaleModeNames(); drawChordIntervalNames(); }
            function drawMainCircle() { ctx.strokeStyle = '#FFFFFF'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(centerX, centerY, circleRadius, 0, 2 * Math.PI); ctx.stroke(); }
            function drawEdoFrequencies() { ctx.fillStyle = '#FFFFFF'; ctx.font = '11px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; edoNotes.forEach(note => ctx.fillText(`${note.frequency.toFixed(1)}Hz`, note.freqX, note.freqY)); }
            function drawRatios() { ctx.fillStyle = '#6495ED'; ctx.font = '12px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; jiNotes.forEach(note => ctx.fillText(note.label, note.ratioX, note.ratioY)); }
            function drawJiFrequencies() { ctx.fillStyle = '#6495ED'; ctx.font = '11px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; jiNotes.forEach(note => ctx.fillText(`${note.frequency.toFixed(1)}Hz`, note.freqX, note.freqY)); }
            function drawIntervalNames() { ctx.fillStyle = '#6495ED'; ctx.font = '11px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; jiNotes.forEach(note => ctx.fillText(note.name, note.nameX, note.nameY)); }
            function drawConnectingLines() { if (path.length <= 1) return; ctx.strokeStyle = '#CCCCCC'; ctx.lineWidth = 1.5; ctx.beginPath(); ctx.moveTo(edoNotes[path[0]].x, edoNotes[path[0]].y); path.slice(1).forEach(index => ctx.lineTo(edoNotes[index].x, edoNotes[index].y)); ctx.stroke(); }
            function drawJiPath() { if (jiPath.length <= 1) return; ctx.strokeStyle = '#6495ED'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(jiPath[0].x, jiPath[0].y); jiPath.slice(1).forEach(point => ctx.lineTo(point.x, point.y)); ctx.stroke(); }
            function drawEDONotes() {
                edoNotes.forEach((note, index) => {
                    ctx.beginPath();
                    ctx.arc(note.x, note.y, noteRadius, 0, 2 * Math.PI);
                    let fillStyle = '#000000'; // Default
                    if (selectedScalePath.includes(index)) {
                        fillStyle = (index === scaleStartNote) ? '#00C853' : '#006400';
                    }
                    if (index === currentNoteIndex) {
                        fillStyle = (index === scaleStartNote) ? '#00C853' : '#888888'; // Grey unless it's the scale root
                    }
                    ctx.fillStyle = fillStyle;
                    ctx.fill();
                    ctx.strokeStyle = '#FFFFFF'; ctx.stroke();
                    ctx.fillStyle = '#FFFFFF'; ctx.font = `${Math.max(8, noteRadius * 0.75)}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText(note.label, note.x, note.y);
                });
            }
            function drawScalePath() { if (selectedScalePath.length <= 1) return; ctx.strokeStyle = '#28a745'; ctx.lineWidth = 2.5; ctx.lineCap = 'round'; ctx.beginPath(); ctx.moveTo(edoNotes[selectedScalePath[0]].x, edoNotes[selectedScalePath[0]].y); selectedScalePath.slice(1).forEach(index => ctx.lineTo(edoNotes[index].x, edoNotes[index].y)); ctx.lineTo(edoNotes[selectedScalePath[0]].x, edoNotes[selectedScalePath[0]].y); ctx.stroke(); }
            function drawScaleModeNames() { const scaleNameRadius = circleRadius * 1.45; ctx.fillStyle = '#28a745'; ctx.font = '11px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; selectedScalePath.forEach((noteIndex, i) => { if (scaleModeNames[i]) { const note = edoNotes[noteIndex]; const angle = note.angle; const x = centerX + scaleNameRadius * Math.cos(angle); const y = centerY + scaleNameRadius * Math.sin(angle); ctx.fillText(scaleModeNames[i], x, y); } }); }
            function drawChordPath() { if (selectedChordPath.length <= 1) return; ctx.strokeStyle = '#ff4136'; ctx.lineWidth = 3; ctx.beginPath(); selectedChordPath.forEach(index => { ctx.moveTo(centerX, centerY); ctx.lineTo(edoNotes[index].x, edoNotes[index].y); }); ctx.stroke(); }
            function drawChordIntervalNames() { const nameRadius = circleRadius * 1.15; ctx.fillStyle = '#ff4136'; ctx.font = 'bold 11px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; selectedChordPath.forEach((noteIndex, i) => { if (chordIntervalNames[i]) { const note = edoNotes[noteIndex]; const angle = note.angle; const x = centerX + nameRadius * Math.cos(angle); const y = centerY + nameRadius * Math.sin(angle); ctx.fillText(chordIntervalNames[i], x, y); } }); }
            function updateControls() {
                const hasRoot = currentNoteIndex !== null; const pathIsPlayable = path.length >= 2; const jiPathIsPlayable = jiPath.length > 0; const scaleIsSelected = selectedScalePath.length > 0; const chordIsSelected = selectedChordPath.length > 0;
                allFloatingControls.forEach(el => el.disabled = isAnimating || isPlayingScale);
                if (!isAnimating && !isPlayingScale) {
                    intervalSelect.disabled = !hasRoot || isPlayMode; addIntervalBtn.disabled = !hasRoot || isPlayMode; resetEdoPathBtn.disabled = path.length <= 1;
                    rollLeftBtn.disabled = !hasRoot || isPlayMode; rollRightBtn.disabled = !hasRoot || isPlayMode;
                    playModeBtn.disabled = false; playChordBtn.disabled = !pathIsPlayable || isPlayMode; playScaleBtn.disabled = !pathIsPlayable || isPlayMode;
                    draw32Btn.disabled = !hasRoot || isPlayMode; resetJiPathBtn.disabled = !jiPathIsPlayable; toggleNamesBtn.disabled = !showRatios;
                    rollScaleLeftBtn.disabled = !scaleIsSelected || isPlayMode; rollScaleRightBtn.disabled = !scaleIsSelected || isPlayMode; playLibraryScaleBtn.disabled = !scaleIsSelected || isPlayMode; scaleInfoBtn.disabled = !scaleIsSelected || isPlayMode;
                    rollChordLeftBtn.disabled = !chordIsSelected || isPlayMode; rollChordRightBtn.disabled = !chordIsSelected || isPlayMode; playLibraryChordBtn.disabled = !chordIsSelected || isPlayMode;
                }
                if (isPlayMode) { instructions.textContent = 'Play Mode: Click or touch notes to play them.'; } 
                else if (isPlayingScale) { instructions.textContent = 'Playing scale...'; } 
                else if (isAnimating && isPaused) { instructions.textContent = 'Animation Paused.'; } 
                else if (isAnimating) { instructions.textContent = 'Animating...'; } 
                else if (!hasRoot) { instructions.textContent = 'Select a root note on the circle.'; } 
                else if (hasRoot) { instructions.textContent = `Current EDO note: ${currentNoteIndex}. Select an interval or a new root.`; } 
                if (!isAnimating && !isPlayMode) { const currentInterval = intervalSelect.value; intervalSelect.innerHTML = ''; for (let i = 1; i < edo; i++) { const option = document.createElement('option'); option.value = i; option.textContent = i; intervalSelect.appendChild(option); } if (currentInterval) intervalSelect.value = currentInterval; }
            }
            async function initAudio() { if (isAudioInitialized) return; audioContext = new (window.AudioContext || window.webkitAudioContext)(); masterGainNode = audioContext.createGain(); masterGainNode.gain.setValueAtTime(masterVolume, audioContext.currentTime); masterGainNode.connect(audioContext.destination); try { const response = await fetch('base_sound_110hz.wav'); if (!response.ok) throw new Error('File not found'); const arrayBuffer = await response.arrayBuffer(); audioBuffer = await audioContext.decodeAudioData(arrayBuffer); } catch (error) { console.warn('Could not load base_sound_110hz.wav. Falling back to synth pluck.', error.message); audioBuffer = null; } isAudioInitialized = true; }
            function playNote(frequency) { if (!audioContext || audioContext.state === 'suspended') audioContext.resume(); if (audioBuffer) { const source = audioContext.createBufferSource(); source.buffer = audioBuffer; source.playbackRate.value = frequency / 110.0; source.connect(masterGainNode); source.start(0); } else { const osc = audioContext.createOscillator(); const gainNode = audioContext.createGain(); const now = audioContext.currentTime; osc.type = 'triangle'; osc.frequency.setValueAtTime(frequency, now); gainNode.gain.setValueAtTime(0, now); gainNode.gain.linearRampToValueAtTime(0.5, now + 0.01); gainNode.gain.linearRampToValueAtTime(0, now + 0.5); osc.connect(gainNode); gainNode.connect(masterGainNode); osc.start(now); osc.stop(now + 0.5); } }
            async function playScale(scalePath) { if (scalePath.length < 2 || isPlayingScale) return; isPlayingScale = true; updateControls(); const runPlayback = async () => { for (const noteIndex of scalePath) { playNote(edoNotes[noteIndex].frequency); await new Promise(resolve => setTimeout(resolve, 150)); } }; if (!isAudioInitialized) { await initAudio(); } await runPlayback(); isPlayingScale = false; updateControls(); }
            function playLibraryChord() { if (selectedChordPath.length < 1) return; const play = () => selectedChordPath.map(noteIndex => edoNotes[noteIndex].frequency).forEach(freq => playNote(freq)); if (!isAudioInitialized) { initAudio().then(play); } else { play(); } }
            function togglePlayMode() { if (!isAudioInitialized) initAudio(); isPlayMode = !isPlayMode; playModeBtn.classList.toggle('play-mode-active', isPlayMode); canvas.classList.toggle('play-mode', isPlayMode); rootNoteIndex = currentNoteIndex = null; path = []; jiPath = []; selectedScaleSteps = null; selectedScalePath = []; selectedChordSteps = null; selectedChordPath = []; updateControls(); draw(); if (!isPlayMode) { setDefaultRootNote(); } }
            function handleCanvasInteraction(e) { const rect = canvas.getBoundingClientRect(); const x = e.touches ? e.touches[0].clientX - rect.left : e.clientX - rect.left; const y = e.touches ? e.touches[0].clientY - rect.top : e.clientY - rect.top; if (isPlayMode) { for (const note of edoNotes) { if (Math.sqrt((x - note.x)**2 + (y - note.y)**2) < note.hitRadius) { playNote(note.frequency); return; } } if (showRatios) { for (const note of jiNotes) { if (Math.sqrt((x - note.ratioX)**2 + (y - note.ratioY)**2) < note.hitRadius) { playNote(note.frequency); return; } } } } else { if (path.length > 1 || isAnimating) return; for (const [index, note] of edoNotes.entries()) { if (Math.sqrt((x - note.x)**2 + (y - note.y)**2) < note.hitRadius) { rootNoteIndex = currentNoteIndex = index; path = [index]; if(selectedScaleSteps) { scaleStartNote = rootNoteIndex; calculateScalePath(); } if(selectedChordSteps) { chordStartNote = rootNoteIndex; calculateChordPath(); } updateControls(); draw(); break; } } } }
            
            // --- UI Interaction (Drag & Toggle) ---
            function initializeControlPanels() {
                document.querySelectorAll('.control-section').forEach(section => {
                    const header = section.querySelector('.section-header');
                    const toggleBtn = section.querySelector('.toggle-vis-btn');
                    let active = false, initialX, initialY;
                    const dragStart = (e) => { header.classList.add('dragging'); if (e.type === "touchstart") { initialX = e.touches[0].clientX - section.offsetLeft; initialY = e.touches[0].clientY - section.offsetTop; } else { initialX = e.clientX - section.offsetLeft; initialY = e.clientY - section.offsetTop; } active = true; };
                    const dragEnd = () => { header.classList.remove('dragging'); active = false; };
                    const drag = (e) => { if (active) { e.preventDefault(); let currentX, currentY; if (e.type === "touchmove") { currentX = e.touches[0].clientX - initialX; currentY = e.clientY - initialY; } else { currentX = e.clientX - initialX; currentY = e.clientY - initialY; } section.style.left = `${currentX}px`; section.style.top = `${currentY}px`; } };
                    header.addEventListener("mousedown", dragStart); header.addEventListener("touchstart", dragStart);
                    document.addEventListener("mouseup", dragEnd); document.addEventListener("touchend", dragEnd);
                    document.addEventListener("mousemove", drag); document.addEventListener("touchmove", drag, {passive: false});
                    toggleBtn.addEventListener('click', (e) => { e.stopPropagation(); section.querySelector('.section-content').classList.toggle('hidden'); });
                });
            }

            // --- Scale & Chord Library Functions ---
            function populateScaleSelect(filter = '') { const currentVal = scaleSelect.value; scaleSelect.innerHTML = '<option value="-1">Select a scale...</option>'; const lowerFilter = filter.toLowerCase(); scaleLibrary.forEach((scale, index) => { if (scale.edo !== edo) return; const stepsString = scale.steps.join(','); const searchableString = `${scale.name} ${stepsString} ${scale.aliases.join(' ')}`.toLowerCase(); if (filter === '' || searchableString.includes(lowerFilter)) { const option = document.createElement('option'); option.value = index; option.textContent = `${scale.name} [${stepsString}]`; scaleSelect.appendChild(option); } }); scaleSelect.value = currentVal; }
            function populateChordSelect(filter = '') { const currentVal = chordSelect.value; chordSelect.innerHTML = '<option value="-1">Select a chord...</option>'; const lowerFilter = filter.toLowerCase(); chordLibrary.forEach((chord, index) => { if (chord.edo !== edo) return; const stepsString = chord.steps.join(','); const searchableString = `${chord.name} ${stepsString} ${chord.aliases.join(' ')}`.toLowerCase(); if (filter === '' || searchableString.includes(lowerFilter)) { const option = document.createElement('option'); option.value = index; option.textContent = `${chord.name} [${stepsString}]`; chordSelect.appendChild(option); } }); chordSelect.value = currentVal; }
            function calculateScalePath() { if (!selectedScaleSteps) return; let current = scaleStartNote; selectedScalePath = [current]; for (let i = 0; i < selectedScaleSteps.length - 1; i++) { current = (current + selectedScaleSteps[i]) % edo; selectedScalePath.push(current); } calculateModeNames(); }
            function calculateChordPath() { if (!selectedChordSteps) return; let current = chordStartNote; selectedChordPath = [current]; chordIntervalNames = [INTERVAL_NAMES_12_EDO[0] || 'R']; selectedChordSteps.forEach(step => { current = (chordStartNote + step) % edo; selectedChordPath.push(current); chordIntervalNames.push(INTERVAL_NAMES_12_EDO[step] || '?'); }); }
            function rollScalePath(direction) { if (!selectedScaleSteps) return; scaleStartNote = (scaleStartNote + direction + edo) % edo; currentNoteIndex = rootNoteIndex = scaleStartNote; path = [currentNoteIndex]; calculateScalePath(); updateScaleInfoDisplay(); updateControls(); draw(); }
            function rollChordPath(direction) { if (!selectedChordSteps) return; chordStartNote = (chordStartNote + direction + edo) % edo; currentNoteIndex = rootNoteIndex = chordStartNote; path = [currentNoteIndex]; calculateChordPath(); updateControls(); draw(); }
            function calculateModeNames() { if (!selectedScaleSteps) { scaleModeNames = []; return; } const numSteps = selectedScaleSteps.length; scaleModeNames = []; for (let i = 0; i < numSteps; i++) { const rolledSteps = [...selectedScaleSteps.slice(i), ...selectedScaleSteps.slice(0, i)]; const foundScale = scaleLibrary.find(s => s.edo === edo && s.steps.toString() === rolledSteps.toString()); scaleModeNames.push(foundScale ? foundScale.name.split(' ')[0] : `Mode ${i+1}`); } }
            function detectUserScale() { if (path.length < 2) { if (selectedScaleSteps) { selectedScaleSteps = null; selectedScalePath = []; scaleModeNames = []; scaleSelect.value = -1; updateScaleInfoDisplay(); } return; } const userSteps = []; for(let i=0; i<path.length-1; i++){ userSteps.push((path[i+1] - path[i] + edo) % edo); } const total = userSteps.reduce((a, b) => a + b, 0); if (total >= edo) { if (selectedScaleSteps) { selectedScaleSteps = null; selectedScalePath = []; scaleModeNames = []; scaleSelect.value = -1; updateScaleInfoDisplay(); } return; } for (let i = 0; i < scaleLibrary.length; i++) { const scale = scaleLibrary[i]; if (scale.edo !== edo || scale.steps.length !== userSteps.length) continue; let currentSteps = [...scale.steps]; for(let j=0; j<currentSteps.length; j++){ if(currentSteps.toString() === userSteps.toString()){ if (parseInt(scaleSelect.value) !== i) { scaleSelect.value = i; } selectedScaleSteps = scale.steps; const stepsToRoot = currentSteps.slice(0, j).reduce((acc, val) => acc + val, 0); scaleStartNote = (path[0] - stepsToRoot + edo) % edo; calculateScalePath(); updateScaleInfoDisplay(); return; } currentSteps.push(currentSteps.shift()); } } if (selectedScaleSteps) { selectedScaleSteps = null; selectedScalePath = []; scaleModeNames = []; scaleSelect.value = -1; updateScaleInfoDisplay(); } }
            function detectChordsInScale() {
                if (selectedScalePath.length === 0) return [];
                const results = [];
                selectedScalePath.forEach((root, index) => {
                    const chordsOnThisDegree = [];
                    chordLibrary.forEach(chord => {
                        if (chord.edo !== edo) return;
                        const chordNotes = [root, ...chord.steps.map(step => (root + step) % edo)];
                        const isChordInScale = chordNotes.every(note => selectedScalePath.includes(note));
                        if (isChordInScale) {
                            chordsOnThisDegree.push(chord.name);
                        }
                    });
                    results.push(`<li>${index + 1} (Note ${root}): ${chordsOnThisDegree.join(', ') || 'None'}</li>`);
                });
                return results;
            }
            function updateScaleInfoDisplay() {
                const scaleIndex = parseInt(scaleSelect.value, 10);
                if (showScaleInfo && scaleIndex > -1) {
                    const scale = scaleLibrary[scaleIndex];
                    let html = `<h4>${scale.name}</h4>`;
                    html += `<p><strong>Steps:</strong> [${scale.steps.join(', ')}]</p>`;
                    if (scale.aliases.length > 0) html += `<p><strong>Aliases:</strong> ${scale.aliases.join(', ')}</p>`;
                    if (scaleModeNames.length > 0) { html += `<p><strong>Modes:</strong></p><ul>`; scaleModeNames.forEach((name, i) => { html += `<li>${i + 1}: ${name}</li>`; }); html += `</ul>`; }
                    const chordsInScale = detectChordsInScale();
                    if(chordsInScale.length > 0) { html += `<p><strong>Chords in Scale:</strong></p><ul>${chordsInScale.join('')}</ul>`; }
                    scaleInfoDisplay.innerHTML = html;
                    scaleInfoDisplay.classList.remove('hidden');
                } else {
                    scaleInfoDisplay.classList.add('hidden');
                }
            }
            
            // --- Animation Engine ---
            const easeInOut=t=>t<.5?2*t*t:-1+(4-2*t)*t;let animData,highlightStages,stageStartTimes;function startAnimation(){if(isAnimating)return;isAnimating=!0;isPaused=!1;pausedTime=0;pausePlayBtn.textContent="Pause";animationControls.style.display="flex";rootNoteIndex=currentNoteIndex=null;path=[];jiPath=[];updateControls();resizeAndRecalculate();generateAllNotes();const e=canvas.width*.8,t=canvas.width*.1,n=centerY,o=centerY+60,i=jiNotes.map(a=>({x:t+a.cents/1200*e,y:n})),s=jiNotes.map(a=>({x:a.ratioX,y:a.ratioY})),l=[...jiNotes,{label:"2/1"}],r=[...i,{x:t+e,y:n}],d=[...s,{x:s[0].x,y:s[0].y}];animData={jiNotes:l,linePositions:r,circlePositions:d,lineLength:e,lineStartX:t,lineY:n,textY:o,rootPoint:r[0],octavePoint:r[r.length-1],p5Point:r[l.findIndex(a=>"3/2"===a.label)],p4Point:r[l.findIndex(a=>"4/3"===a.label)],M3Point:r[l.findIndex(a=>"5/4"===a.label)],m3Point:r[l.findIndex(a=>"6/5"===a.label)],M2Point:r[l.findIndex(a=>"9/8"===a.label)],M6Point:r[l.findIndex(a=>"5/3"===a.label)],m2Point:r[l.findIndex(a=>"16/15"===a.label)],M7Point:r[l.findIndex(a=>"15/8"===a.label)],tritonePoint:r[l.findIndex(a=>"45/32"===a.label)],m6Point:r[l.findIndex(a=>"8/5"===a.label)],m7Point:r[l.findIndex(a=>"9/5"===a.label)]};highlightStages=[{name:"SHOW_ROOT",point:animData.rootPoint,text:[`${baseFrequency.toFixed(1)} Hz`,"The root is the 1st harmonic."]},{name:"SHOW_OCTAVE",point:animData.octavePoint,text:[`${(2*baseFrequency).toFixed(1)} Hz`,"The 2nd harmonic is 2 times the root."]},{name:"SHOW_PERFECT_FIFTH",point:animData.p5Point,text:["The 3rd harmonic divided by 2 to keep it in the circle."]},{name:"SHOW_FOURTH_HARMONIC",point:animData.octavePoint,text:[`${(4*baseFrequency).toFixed(1)} Hz`,"The 4th harmonic is 2 times the 2nd harmonic."]},{name:"SHOW_PERFECT_FOURTH",point:animData.p4Point,text:["The 3rd harmonic inverted and multiplied by 4 to be in the circle."]},{name:"SHOW_MAJOR_THIRD",point:animData.M3Point,text:[`${(5*baseFrequency).toFixed(1)} Hz`,"The 5th harmonic is divided by 4 to keep it in the circle."]},{name:"SHOW_MINOR_THIRD",point:animData.m3Point,text:["The interval between the 5th and 6th harmonics, or the 19th harmonic."]},{name:"SHOW_DERIVED_M2",point:animData.M2Point,text:["(3/2) * (3/2) = 9/8,","or the 9th harmonic divided to be in the circle."],components:[animData.p5Point]},{name:"SHOW_DERIVED_M6",point:animData.M6Point,text:["(5/4) * (4/3) = 5/3"],components:[animData.M3Point,animData.p4Point]},{name:"SHOW_DERIVED_m2",point:animData.m2Point,text:["(4/3) / (5/4) = 16/15"],components:[animData.p4Point,animData.M3Point]},{name:"SHOW_DERIVED_M7",point:animData.M7Point,text:["(5/4) * (3/2) = 15/8"],components:[animData.M3Point,animData.p5Point]},{name:"SHOW_DERIVED_TRITONE",point:animData.tritonePoint,text:["(15/8) * (3/2) = 45/32"],components:[animData.M7Point,animData.p5Point]},{name:"SHOW_DERIVED_m6",point:animData.m6Point,text:["(16/15) * (3/2) = 8/5"],components:[animData.m2Point,animData.p5Point]},{name:"SHOW_DERIVED_m7",point:animData.m7Point,text:["(6/5) * (3/2) = 9/5"],components:[animData.m3Point,animData.p5Point]}];let a=0;stageStartTimes=ANIMATION_STAGES.map(e=>(a+=e.duration)-e.duration);startTime=performance.now();animationFrameId=requestAnimationFrame(animationLoop)}
            function animationLoop(e){const t=e-startTime,n=stageStartTimes.findIndex((e,n)=>t<e+ANIMATION_STAGES[n].duration);if(-1===n||t>=TOTAL_ANIMATION_DURATION)return void stopAnimation();const o=ANIMATION_STAGES[n],i=t-stageStartTimes[n],s=i/o.duration;drawAnimationFrame(o.name,n,s,animData,highlightStages),animationFrameId=requestAnimationFrame(animationLoop)}
            function stopAnimation(){if(!isAnimating)return;cancelAnimationFrame(animationFrameId);isAnimating=!1;isPaused=!1;animationControls.style.display="none";setup();setDefaultRootNote()}
            function togglePause(){if(!isAnimating)return;isPaused=!isPaused;isPaused?(cancelAnimationFrame(animationFrameId),pausedTime=performance.now()-startTime,pausePlayBtn.textContent="Play"):(startTime=performance.now()-pausedTime,pausePlayBtn.textContent="Pause",animationFrameId=requestAnimationFrame(animationLoop)),updateControls()}
            function drawAnimationFrame(e,t,n,o,i){ctx.clearRect(0,0,canvas.width,canvas.height);const s=easeInOut(n),l=(e,t)=>{ctx.strokeStyle="rgba(100, 149, 237, 1)";ctx.lineWidth=1.5;ctx.beginPath();ctx.moveTo(e[0].x,e[0].y);e.slice(1).forEach(e=>{ctx.lineTo(e.x,e.y)});ctx.stroke()},r=(e,t)=>{ctx.fillStyle="rgba(100, 149, 237, 1)";ctx.font="12px Arial";ctx.textAlign="center";ctx.textBaseline="bottom";e.forEach((e,n)=>{ctx.fillText(o.jiNotes[n].label,e.x,e.y-5)})},d=(e,t=1)=>{ctx.fillStyle=`rgba(0, 200, 83, ${.5*t})`;ctx.beginPath();ctx.arc(e.x,e.y,15,0,2*Math.PI);ctx.fill()},a=e=>{ctx.fillStyle="rgba(255, 215, 0, 0.4)";ctx.beginPath();ctx.arc(e.x,e.y,15,0,2*Math.PI);ctx.fill()},c=e=>{ctx.fillStyle="rgba(255, 0, 255, 0.5)";ctx.beginPath();ctx.arc(e.x,e.y,15,0,2*Math.PI);ctx.fill()},u=(e,t=0)=>{ctx.fillStyle="rgba(255, 255, 255, 1)";ctx.font="14px Arial";ctx.textAlign="center";ctx.textBaseline="middle";ctx.fillText(e,centerX,o.textY+t)};let m=1,p=o.circlePositions;const f=ANIMATION_STAGES.findIndex(e=>"UNROLL"===e.name),h=ANIMATION_STAGES.findIndex(e=>"ROLL_BACK"===e.name);if(t>=f){const i="UNROLL"===e?s:1;m=1-i,p=o.circlePositions.map((e,t)=>({x:e.x+(o.linePositions[t].x-e.x)*i,y:e.y+(o.linePositions[t].y-e.y)*i}))}"ROLL_BACK"===e&&(p=o.linePositions.map((e,t)=>({x:e.x+(o.circlePositions[t].x-e.x)*s,y:e.y+(o.circlePositions[t].y-e.y)*s}))),t>h&&(p=o.circlePositions);ctx.globalAlpha=m;drawMainCircle();drawEDONotes();ctx.globalAlpha=1;l(p);r(p);const g=ANIMATION_STAGES.findIndex(e=>"CLEAR_HIGHLIGHTS"===e.name);if(i.forEach(n=>{const i=ANIMATION_STAGES.findIndex(t=>t.name===n.name);t>=i&&t<g&&d(n.point,1),e===n.name&&(n.text.forEach((e,t)=>{u(e,20*t)}),n.components&&n.components.forEach(e=>{a(e)}),"SHOW_DERIVED_M2"===e?c(o.M2Point):"SHOW_DERIVED_m2"===e?c(o.m2Point):"SHOW_DERIVED_M6"===e?c(o.M6Point):"SHOW_DERIVED_M7"===e?c(o.M7Point):"SHOW_DERIVED_TRITONE"===e?c(o.tritonePoint):"SHOW_DERIVED_m6"===e?c(o.m6Point):"SHOW_DERIVED_m7"===e&&c(o.m7Point))}),"SHOW_THIRD_HARMONIC"===e){const t=o.lineStartX+o.lineLength*(Math.log2(3)/Math.log2(2)),n=o.octavePoint.x+(t-o.octavePoint.x)*s;ctx.strokeStyle="rgba(255, 100, 100, 0.7)";ctx.lineWidth=2;ctx.beginPath();ctx.moveTo(o.octavePoint.x,o.octavePoint.y);ctx.lineTo(n,o.octavePoint.y);ctx.stroke();if(s>.9){const e=Math.min(1,(s-.9)/.1);ctx.fillStyle=`rgba(255, 100, 100, ${.5*e})`;ctx.beginPath();ctx.arc(t,o.lineY,15,0,2*Math.PI);ctx.fill();ctx.fillStyle=`rgba(255, 255, 255, ${e})`;ctx.font="12px Arial";ctx.textAlign="center";ctx.textBaseline="bottom";ctx.fillText("3/1",t,o.lineY-5)}u(`${(3*baseFrequency).toFixed(1)} Hz`);u("The 3rd harmonic is 3 times the root.",20)}else"CLEAR_HIGHLIGHTS"===e?i.forEach(e=>{d(e.point,1-s)}):"FADE_IN_EDO"===e&&(ctx.globalAlpha=s,drawMainCircle(),drawEDONotes(),ctx.globalAlpha=1)}

            // --- Event Handlers ---
            playModeBtn.addEventListener('click', togglePlayMode);
            playChordBtn.addEventListener('click', () => playScale(path));
            playScaleBtn.addEventListener('click', () => playScale(path));
            volumeSlider.addEventListener('input', (e) => { masterVolume = parseFloat(e.target.value); if (masterGainNode) { masterGainNode.gain.setValueAtTime(masterVolume, audioContext.currentTime); }});
            draw32Btn.addEventListener('click', () => { let startPoint, startAngle; if (jiPath.length === 0) { if (currentNoteIndex === null) return; const startNote = edoNotes[currentNoteIndex]; startPoint = { x: startNote.x, y: startNote.y }; startAngle = startNote.angle; jiPath = [startPoint]; } else { startPoint = jiPath[jiPath.length - 1]; startAngle = Math.atan2(startPoint.y - centerY, startPoint.x - centerX); } const endAngle = startAngle + JI_PERFECT_FIFTH_RADIANS; const endX = centerX + circleRadius * Math.cos(endAngle); const endY = centerY + circleRadius * Math.sin(endAngle); jiPath.push({ x: endX, y: endY }); updateControls(); draw(); });
            edoInput.addEventListener('change', () => { setup(); setDefaultRootNote(); });
            baseFreqInput.addEventListener('change', () => { setup(); setDefaultRootNote(); });
            resetEdoPathBtn.addEventListener('click', resetEdoPath); 
            resetJiPathBtn.addEventListener('click', resetJiPath);
            rollLeftBtn.addEventListener('click', () => rollPath(-1));
            rollRightBtn.addEventListener('click', () => rollPath(1));
            animateBtn.addEventListener('click', startAnimation);
            pausePlayBtn.addEventListener('click', togglePause);
            stopAnimBtn.addEventListener('click', stopAnimation);
            toggleRatiosBtn.addEventListener('click', () => { if(!isAnimating) { showRatios = !showRatios; if (!showRatios) showIntervalNames = false; updateControls(); draw(); }});
            toggleNamesBtn.addEventListener('click', () => { if(!isAnimating && showRatios) { showIntervalNames = !showIntervalNames; draw(); }});
            showEdoFreqsBtn.addEventListener('click', () => { if(!isAnimating) { showEdoFreqs = !showEdoFreqs; draw(); }});
            showJiFreqsBtn.addEventListener('click', () => { if(!isAnimating) { showJiFreqs = !showJiFreqs; draw(); }});
            addIntervalBtn.addEventListener('click', () => { if (currentNoteIndex === null || isAnimating) return; currentNoteIndex = (currentNoteIndex + parseInt(intervalSelect.value)) % edo; path.push(currentNoteIndex); detectUserScale(); updateControls(); draw(); });
            edoZoomSlider.addEventListener('input', (e) => { edoZoom = parseFloat(e.target.value); updateAllRadii(); generateAllNotes(); draw(); });
            jiZoomSlider.addEventListener('input', (e) => { jiZoom = parseFloat(e.target.value); updateAllRadii(); generateJINotes(); draw(); });
            canvas.addEventListener('click', handleCanvasInteraction);
            canvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleCanvasInteraction(e); });
            window.addEventListener('resize', () => { setup(); setDefaultRootNote(); });
            scaleSearchInput.addEventListener('input', (e) => populateScaleSelect(e.target.value));
            scaleSelect.addEventListener('change', (e) => {
                const scaleIndex = parseInt(e.target.value, 10);
                if (scaleIndex === -1) { selectedScaleSteps = null; selectedScalePath = []; scaleModeNames = []; showScaleInfo = false;} 
                else { const scale = scaleLibrary[scaleIndex]; selectedScaleSteps = scale.steps; scaleStartNote = currentNoteIndex !== null ? currentNoteIndex : 0; calculateScalePath(); }
                updateScaleInfoDisplay(); updateControls(); draw();
            });
            rollScaleLeftBtn.addEventListener('click', () => rollScalePath(-1));
            rollScaleRightBtn.addEventListener('click', () => rollScalePath(1));
            playLibraryScaleBtn.addEventListener('click', () => playScale(selectedScalePath));
            scaleInfoBtn.addEventListener('click', () => { showScaleInfo = !showScaleInfo; updateScaleInfoDisplay(); });
            chordSearchInput.addEventListener('input', (e) => populateChordSelect(e.target.value));
            chordSelect.addEventListener('change', (e) => {
                const chordIndex = parseInt(e.target.value, 10);
                if (chordIndex === -1) { selectedChordSteps = null; selectedChordPath = []; }
                else { const chord = chordLibrary[chordIndex]; selectedChordSteps = chord.steps; chordStartNote = currentNoteIndex !== null ? currentNoteIndex : 0; calculateChordPath(); }
                updateControls(); draw();
            });
            rollChordLeftBtn.addEventListener('click', () => rollChordPath(-1));
            rollChordRightBtn.addEventListener('click', () => rollChordPath(1));
            playLibraryChordBtn.addEventListener('click', playLibraryChord);
            
            // Initial setup
            setup();
            setDefaultRootNote();
            initializeControlPanels();
        });
    </script>
</body>
</html>
