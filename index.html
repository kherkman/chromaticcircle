<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Chromatic Circle</title>
    <style>
        html, body {
            margin: 0; padding: 0; height: 100%; overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #000000; color: #FFFFFF;
        }
        body {
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        .controls {
            padding: 10px 15px; margin-bottom: 15px; background-color: #1a1a1a;
            border: 1px solid #333; border-radius: 8px; display: flex;
            flex-wrap: wrap; justify-content: center; align-items: center; gap: 10px 15px;
        }
        label { font-weight: bold; }
        select, input, button {
            background-color: #333; color: #fff; border: 1px solid #555;
            padding: 8px 12px; border-radius: 4px; font-size: 1em; cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s, color 0.2s;
            vertical-align: middle;
        }
        input[type="number"] { width: 60px; }
        input[type="range"] { padding: 0; cursor: grab; }
        select:hover, input:hover, button:hover:not(:disabled) {
            background-color: #444; border-color: #777;
        }
        button:disabled, select:disabled, input:disabled {
            background-color: #222; color: #666; border-color: #444; cursor: not-allowed;
        }
        .play-mode-active { background-color: #00C853; border-color: #00e676; }
        .control-group { display: inline-flex; align-items: center; gap: 8px; }
        .ji-controls {
            border: 1px solid #6495ED; border-radius: 6px; padding: 5px 10px;
            background-color: #111a2e; display: inline-flex; flex-wrap: wrap;
            align-items: center; gap: 8px;
        }
        .divider { border-left: 1px solid #444; margin: 0 5px; height: 25px; }
        #canvas-container { position: relative; }
        #chromaticCircleCanvas.play-mode { cursor: pointer; }
        .instructions {
            margin-top: 15px; color: #aaa; font-style: italic;
            text-align: center; height: 1.2em;
        }
    </style>
</head>
<body>

    <div class="controls">
        <div class="control-group">
            <label for="base-freq-input">Base Hz:</label> <input type="number" id="base-freq-input" value="110" min="1">
            <label for="edo-input">EDO:</label> <input type="number" id="edo-input" value="12" min="1" max="360">
            <button id="show-edo-freqs-btn">EDO Freqs</button>
        </div>
        <div class="control-group">
            <label for="edo-zoom-slider">EDO Zoom:</label> <input type="range" id="edo-zoom-slider" min="0.5" max="2" step="0.01" value="1">
        </div>
        <div class="control-group">
            <label for="volume-slider">Volume:</label>
            <input type="range" id="volume-slider" min="0" max="1" step="0.01" value="0.5">
        </div>
        <button id="reset-btn">Reset</button>
        <div class="divider"></div>
        <div class="ji-controls">
            <button id="toggle-ratios-btn">JI Ratios</button>
            <button id="show-ji-freqs-btn">JI Freqs</button>
            <button id="toggle-names-btn">Names</button>
            <button id="animate-btn">Animate JI</button>
            <button id="draw-32-btn" disabled>Draw 3/2</button>
            <div class="control-group">
                <label for="ji-zoom-slider">JI Zoom:</label> <input type="range" id="ji-zoom-slider" min="0.5" max="2" step="0.01" value="1">
            </div>
        </div>
        <div class="divider"></div>
        <div class="control-group">
            <label for="interval-select">Interval:</label> <select id="interval-select" disabled></select>
            <button id="add-interval-btn" disabled>Add</button>
            <button id="play-mode-btn">Play Mode</button>
            <button id="play-chord-btn" disabled>Play Chord</button>
            <button id="play-scale-btn" disabled>Play Scale</button>
        </div>
    </div>

    <div id="canvas-container"><canvas id="chromaticCircleCanvas"></canvas></div>
    <p id="instructions" class="instructions">Enter an EDO, then click a number on the circle.</p>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM References & State ---
            const allControls = document.querySelectorAll('.controls input, .controls button, .controls select');
            const playModeBtn = document.getElementById('play-mode-btn'), playChordBtn = document.getElementById('play-chord-btn'), playScaleBtn = document.getElementById('play-scale-btn'), draw32Btn = document.getElementById('draw-32-btn');
            const edoInput = document.getElementById('edo-input'), baseFreqInput = document.getElementById('base-freq-input');
            const showEdoFreqsBtn = document.getElementById('show-edo-freqs-btn'), showJiFreqsBtn = document.getElementById('show-ji-freqs-btn');
            const intervalSelect = document.getElementById('interval-select'), addIntervalBtn = document.getElementById('add-interval-btn');
            const resetBtn = document.getElementById('reset-btn');
            const toggleRatiosBtn = document.getElementById('toggle-ratios-btn'), toggleNamesBtn = document.getElementById('toggle-names-btn');
            const animateBtn = document.getElementById('animate-btn');
            const edoZoomSlider = document.getElementById('edo-zoom-slider'), jiZoomSlider = document.getElementById('ji-zoom-slider'), volumeSlider = document.getElementById('volume-slider');
            const instructions = document.getElementById('instructions');
            const canvas = document.getElementById('chromaticCircleCanvas'), ctx = canvas.getContext('2d');

            let edo = 12, rootNoteIndex = null, currentNoteIndex = null, edoZoom = 1, jiZoom = 1, baseFrequency = 110, masterVolume = 0.5;
            let edoNotes = [], jiNotes = [], path = [], jiPath = [];
            let isAnimating = false, isPlayMode = false, isAudioInitialized = false, isPlayingScale = false;
            let showRatios = false, showIntervalNames = false, showEdoFreqs = false, showJiFreqs = false;
            let audioContext, audioBuffer = null, masterGainNode;

            // --- Constants & Maps ---
            const JI_PERFECT_FIFTH_RADIANS = 210.59 * (Math.PI / 180);
            const JUST_INTONATION_RATIOS = [ { label: '1/1', value: 1/1, name: 'Unison' }, { label: '16/15', value: 16/15, name: 'm2' }, { label: '9/8', value: 9/8, name: 'M2' }, { label: '6/5', value: 6/5, name: 'm3' }, { label: '5/4', value: 5/4, name: 'M3' }, { label: '4/3', value: 4/3, name: 'P4' }, { label: '45/32', value: 45/32, name: 'Tritone' }, { label: '3/2', value: 3/2, name: 'P5' }, { label: '8/5', value: 8/5, name: 'm6' }, { label: '5/3', value: 5/3, name: 'M6' }, { label: '9/5', value: 9/5, name: 'm7' }, { label: '15/8', value: 15/8, name: 'M7' } ].sort((a, b) => a.value - b.value);
            
            const ANIMATION_STAGES = [
                { name: 'UNROLL', duration: 2000 },
                { name: 'SHOW_ROOT', duration: 4500 }, { name: 'SHOW_OCTAVE', duration: 4500 },
                { name: 'SHOW_THIRD_HARMONIC', duration: 4500 }, { name: 'SHOW_PERFECT_FIFTH', duration: 5000 },
                { name: 'SHOW_FOURTH_HARMONIC', duration: 4500 }, { name: 'SHOW_PERFECT_FOURTH', duration: 5000 },
                { name: 'SHOW_MAJOR_THIRD', duration: 5000 }, { name: 'SHOW_MINOR_THIRD', duration: 5000 },
                { name: 'SHOW_DERIVED_M2', duration: 5000 }, { name: 'SHOW_DERIVED_M6', duration: 4000 }, { name: 'SHOW_DERIVED_m2', duration: 4000 },
                { name: 'SHOW_DERIVED_M7', duration: 4000 }, { name: 'SHOW_DERIVED_TRITONE', duration: 5000 },
                { name: 'SHOW_DERIVED_m6', duration: 4000 }, { name: 'SHOW_DERIVED_m7', duration: 4000 },
                { name: 'CLEAR_HIGHLIGHTS', duration: 1000 },
                { name: 'ROLL_BACK', duration: 2000 }, { name: 'FADE_IN_EDO', duration: 1000 },
            ];
            const TOTAL_ANIMATION_DURATION = ANIMATION_STAGES.reduce((sum, s) => sum + s.duration, 0);

            // --- Unchanged Functions (pasted for completeness) ---
            function resizeAndRecalculate() { canvasSize = Math.min(window.innerWidth * 0.95, window.innerHeight * 0.75); canvas.width = canvasSize; canvas.height = canvasSize; centerX = canvas.width / 2; centerY = canvas.height / 2; baseCircleRadius = canvas.width * 0.22; updateAllRadii(); }
            function updateAllRadii() { circleRadius = baseCircleRadius * edoZoom; edoFreqLabelRadius = circleRadius * 1.30; ratioLabelRadius = circleRadius * 1.60 * jiZoom; jiFreqLabelRadius = circleRadius * 1.90 * jiZoom; nameLabelRadius = circleRadius * 2.20 * jiZoom; noteRadius = Math.max(9, canvas.width / 50); }
            function setup(isReset = false) { if (isReset) { edoZoomSlider.value = 1; jiZoomSlider.value = 1; volumeSlider.value = 0.5; edoZoom = 1; jiZoom = 1; masterVolume = 0.5; if (masterGainNode) masterGainNode.gain.setValueAtTime(masterVolume, audioContext.currentTime); showRatios = false; showIntervalNames = false; showEdoFreqs = false; showJiFreqs = false; baseFreqInput.value = 110; edoInput.value = 12; if(isPlayMode) togglePlayMode(); } isAnimating = false; let newEdo = parseInt(edoInput.value, 10); if (isNaN(newEdo) || newEdo < 1) newEdo = 12; if (newEdo > 360) newEdo = 360; edoInput.value = newEdo; edo = newEdo; let newFreq = parseFloat(baseFreqInput.value); if (isNaN(newFreq) || newFreq <= 0) newFreq = 110; baseFreqInput.value = newFreq; baseFrequency = newFreq; rootNoteIndex = currentNoteIndex = null; path = []; jiPath = []; resizeAndRecalculate(); generateAllNotes(); updateControls(); draw(); }
            function generateAllNotes() { generateEDONotes(); generateJINotes(); }
            function generateEDONotes() { edoNotes = Array.from({ length: edo }, (_, i) => { const angle = (i / edo) * 2 * Math.PI - Math.PI / 2; const freq = baseFrequency * Math.pow(2, i / edo); return { x: centerX + circleRadius * Math.cos(angle), y: centerY + circleRadius * Math.sin(angle), angle: angle, freqX: centerX + edoFreqLabelRadius * Math.cos(angle), freqY: centerY + edoFreqLabelRadius * Math.sin(angle), label: i, frequency: freq, hitRadius: noteRadius }; }); }
            function generateJINotes() { jiNotes = JUST_INTONATION_RATIOS.map(ratio => { const cents = 1200 * Math.log2(ratio.value); const angle = (cents / 1200) * 2 * Math.PI - Math.PI / 2; const freq = baseFrequency * ratio.value; return { ratioX: centerX + ratioLabelRadius * Math.cos(angle), ratioY: centerY + ratioLabelRadius * Math.sin(angle), freqX: centerX + jiFreqLabelRadius * Math.cos(angle), freqY: centerY + jiFreqLabelRadius * Math.sin(angle), nameX: centerX + nameLabelRadius * Math.cos(angle), nameY: centerY + nameLabelRadius * Math.sin(angle), label: ratio.label, name: ratio.name, cents, frequency: freq, hitRadius: 15 }; }); }
            function draw() { ctx.clearRect(0, 0, canvas.width, canvas.height); drawMainCircle(); if (showEdoFreqs) drawEdoFrequencies(); if (showRatios) drawRatios(); if (showJiFreqs) drawJiFrequencies(); if (showIntervalNames) drawIntervalNames(); drawConnectingLines(); drawJiPath(); drawEDONotes(); }
            function drawMainCircle() { ctx.strokeStyle = '#FFFFFF'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(centerX, centerY, circleRadius, 0, 2 * Math.PI); ctx.stroke(); }
            function drawEdoFrequencies() { ctx.fillStyle = '#FFFFFF'; ctx.font = '11px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; edoNotes.forEach(note => ctx.fillText(`${note.frequency.toFixed(1)}Hz`, note.freqX, note.freqY)); }
            function drawRatios() { ctx.fillStyle = '#6495ED'; ctx.font = '12px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; jiNotes.forEach(note => ctx.fillText(note.label, note.ratioX, note.ratioY)); }
            function drawJiFrequencies() { ctx.fillStyle = '#6495ED'; ctx.font = '11px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; jiNotes.forEach(note => ctx.fillText(`${note.frequency.toFixed(1)}Hz`, note.freqX, note.freqY)); }
            function drawIntervalNames() { ctx.fillStyle = '#6495ED'; ctx.font = '11px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; jiNotes.forEach(note => ctx.fillText(note.name, note.nameX, note.nameY)); }
            function drawConnectingLines() { if (path.length <= 1) return; ctx.strokeStyle = '#CCCCCC'; ctx.lineWidth = 1.5; ctx.beginPath(); ctx.moveTo(edoNotes[path[0]].x, edoNotes[path[0]].y); path.slice(1).forEach(index => ctx.lineTo(edoNotes[index].x, edoNotes[index].y)); ctx.stroke(); }
            function drawJiPath() { if (jiPath.length <= 1) return; ctx.strokeStyle = '#6495ED'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(jiPath[0].x, jiPath[0].y); jiPath.slice(1).forEach(point => ctx.lineTo(point.x, point.y)); ctx.stroke(); }
            function drawEDONotes() { edoNotes.forEach((note, index) => { ctx.beginPath(); ctx.arc(note.x, note.y, noteRadius, 0, 2 * Math.PI); ctx.fillStyle = (index === currentNoteIndex) ? '#00C853' : '#000000'; ctx.fill(); ctx.strokeStyle = '#FFFFFF'; ctx.stroke(); ctx.fillStyle = '#FFFFFF'; ctx.font = `${Math.max(8, noteRadius * 0.75)}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(note.label, note.x, note.y); }); }
            function updateControls() { const hasRoot = currentNoteIndex !== null; const pathIsPlayable = path.length >= 2; allControls.forEach(el => el.disabled = isAnimating || isPlayingScale); if (!isAnimating && !isPlayingScale) { intervalSelect.disabled = !hasRoot || isPlayMode; addIntervalBtn.disabled = !hasRoot || isPlayMode; playModeBtn.disabled = false; playChordBtn.disabled = !pathIsPlayable || isPlayMode; playScaleBtn.disabled = !pathIsPlayable || isPlayMode; draw32Btn.disabled = (currentNoteIndex === null && jiPath.length === 0) || isPlayMode; toggleNamesBtn.disabled = !showRatios; } else { playModeBtn.disabled = true; } if (isPlayMode) { instructions.textContent = 'Play Mode: Click or touch notes to play them.'; } else if (isPlayingScale) { instructions.textContent = 'Playing scale...'; } else if (!hasRoot && !isAnimating && jiPath.length === 0) { instructions.textContent = 'Enter Base Hz & EDO, then click a number.'; } else if (hasRoot) { instructions.textContent = `Current EDO note: ${currentNoteIndex}. Select an interval.`; } else if (jiPath.length > 0) { instructions.textContent = 'Building a Just Intonation path. Click "Draw 3/2" to continue.'; } else { instructions.textContent = `Animating...`; } if (!isAnimating && !isPlayMode) { const currentInterval = intervalSelect.value; intervalSelect.innerHTML = ''; for (let i = 1; i < edo; i++) { const option = document.createElement('option'); option.value = i; option.textContent = i; intervalSelect.appendChild(option); } if (currentInterval) intervalSelect.value = currentInterval; } }
            const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));
            async function initAudio() { if (isAudioInitialized) return; audioContext = new (window.AudioContext || window.webkitAudioContext)(); masterGainNode = audioContext.createGain(); masterGainNode.gain.setValueAtTime(masterVolume, audioContext.currentTime); masterGainNode.connect(audioContext.destination); try { const response = await fetch('base_sound_110hz.wav'); if (!response.ok) throw new Error('File not found'); const arrayBuffer = await response.arrayBuffer(); audioBuffer = await audioContext.decodeAudioData(arrayBuffer); console.log('Successfully loaded base_sound_110hz.wav'); } catch (error) { console.warn('Could not load base_sound_110hz.wav. Falling back to synth pluck.', error.message); audioBuffer = null; } isAudioInitialized = true; }
            function playNote(frequency) { if (!audioContext || audioContext.state === 'suspended') audioContext.resume(); if (audioBuffer) { const source = audioContext.createBufferSource(); source.buffer = audioBuffer; source.playbackRate.value = frequency / 110.0; source.connect(masterGainNode); source.start(0); } else { const osc = audioContext.createOscillator(); const gainNode = audioContext.createGain(); const now = audioContext.currentTime; osc.type = 'triangle'; osc.frequency.setValueAtTime(frequency, now); gainNode.gain.setValueAtTime(0, now); gainNode.gain.linearRampToValueAtTime(0.5, now + 0.01); gainNode.gain.linearRampToValueAtTime(0, now + 0.5); osc.connect(gainNode); gainNode.connect(masterGainNode); osc.start(now); osc.stop(now + 0.5); } }
            function playChord() { if (path.length < 2) return; const play = () => path.map(noteIndex => edoNotes[noteIndex].frequency).forEach(freq => playNote(freq)); if (!isAudioInitialized) { initAudio().then(play); } else { play(); } }
            async function playScale() { if (path.length < 2 || isPlayingScale) return; isPlayingScale = true; updateControls(); const runPlayback = async () => { for (const noteIndex of path) { playNote(edoNotes[noteIndex].frequency); await sleep(150); } }; if (!isAudioInitialized) { await initAudio(); } await runPlayback(); isPlayingScale = false; updateControls(); }
            function togglePlayMode() { if (!isAudioInitialized) initAudio(); isPlayMode = !isPlayMode; playModeBtn.classList.toggle('play-mode-active', isPlayMode); canvas.classList.toggle('play-mode', isPlayMode); rootNoteIndex = currentNoteIndex = null; path = []; jiPath = []; updateControls(); draw(); }
            function handleCanvasInteraction(e) { if (isPlayMode) { const rect = canvas.getBoundingClientRect(); const x = e.touches ? e.touches[0].clientX - rect.left : e.clientX - rect.left; const y = e.touches ? e.touches[0].clientY - rect.top : e.clientY - rect.top; for (const note of edoNotes) { if (Math.sqrt((x - note.x)**2 + (y - note.y)**2) < note.hitRadius) { playNote(note.frequency); return; } } if (showRatios) { for (const note of jiNotes) { if (Math.sqrt((x - note.ratioX)**2 + (y - note.ratioY)**2) < note.hitRadius) { playNote(note.frequency); return; } } } } else { if (rootNoteIndex !== null || isAnimating) return; const rect = canvas.getBoundingClientRect(); const x = e.clientX - rect.left; const y = e.clientY - rect.top; for (const [index, note] of edoNotes.entries()) { if (Math.sqrt((x - note.x)**2 + (y - note.y)**2) < note.hitRadius) { rootNoteIndex = currentNoteIndex = index; path = [index]; jiPath = []; updateControls(); draw(); break; } } } }

            // --- Animation Engine ---
            const easeInOut = t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;

            function startAnimation() {
                if (isAnimating) return;
                isAnimating = true; rootNoteIndex = currentNoteIndex = null; path = []; jiPath = [];
                updateControls();
                
                const lineLength = canvas.width * 0.8;
                const lineStartX = canvas.width * 0.1;
                const lineY = centerY; 
                const textY = centerY + 60; // Repositioned text

                const baseLinePositions = jiNotes.map(note => ({ x: lineStartX + (note.cents / 1200) * lineLength, y: lineY }));
                const baseCirclePositions = jiNotes.map(note => ({ x: note.ratioX, y: note.ratioY }));
                const animJiNotes = [...jiNotes, { label: '2/1' }];
                const animLinePositions = [...baseLinePositions, { x: lineStartX + lineLength, y: lineY }];
                const animCirclePositions = [...baseCirclePositions, { x: baseCirclePositions[0].x, y: baseCirclePositions[0].y }];

                const animData = {
                    jiNotes: animJiNotes, linePositions: animLinePositions, circlePositions: animCirclePositions, 
                    lineLength, lineStartX, lineY, textY,
                    rootPoint: animLinePositions[0],
                    octavePoint: animLinePositions[animLinePositions.length - 1],
                    p5Point: animLinePositions[animJiNotes.findIndex(n => n.label === '3/2')], p4Point: animLinePositions[animJiNotes.findIndex(n => n.label === '4/3')],
                    M3Point: animLinePositions[animJiNotes.findIndex(n => n.label === '5/4')], m3Point: animLinePositions[animJiNotes.findIndex(n => n.label === '6/5')],
                    M2Point: animLinePositions[animJiNotes.findIndex(n => n.label === '9/8')], M6Point: animLinePositions[animJiNotes.findIndex(n => n.label === '5/3')],
                    m2Point: animLinePositions[animJiNotes.findIndex(n => n.label === '16/15')], M7Point: animLinePositions[animJiNotes.findIndex(n => n.label === '15/8')],
                    tritonePoint: animLinePositions[animJiNotes.findIndex(n => n.label === '45/32')], m6Point: animLinePositions[animJiNotes.findIndex(n => n.label === '8/5')],
                    m7Point: animLinePositions[animJiNotes.findIndex(n => n.label === '9/5')]
                };

                let cumulativeTime = 0;
                const stageStartTimes = ANIMATION_STAGES.map(s => { const startTime = cumulativeTime; cumulativeTime += s.duration; return startTime; });
                const startTime = performance.now();
                
                requestAnimationFrame(function animationLoop(currentTime) {
                    const elapsed = currentTime - startTime;
                    const stageIndex = stageStartTimes.findIndex((st, i) => elapsed < st + ANIMATION_STAGES[i].duration);
                    if (stageIndex === -1) { isAnimating = false; updateControls(); draw(); return; }

                    const currentStage = ANIMATION_STAGES[stageIndex];
                    const stageElapsed = elapsed - stageStartTimes[stageIndex];
                    const stageProgress = stageElapsed / currentStage.duration;
                    drawAnimationFrame(currentStage.name, stageIndex, stageProgress, animData);

                    if (elapsed < TOTAL_ANIMATION_DURATION) { requestAnimationFrame(animationLoop); } 
                    else { isAnimating = false; updateControls(); draw(); }
                });
            }

            function drawAnimationFrame(stageName, stageIndex, progress, data) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                const easedProgress = easeInOut(progress);

                const drawBaseJiLine = (points) => { ctx.strokeStyle = `rgba(100, 149, 237, 1)`; ctx.lineWidth = 1.5; ctx.beginPath(); ctx.moveTo(points[0].x, points[0].y); points.slice(1).forEach(p => ctx.lineTo(p.x, p.y)); ctx.stroke(); };
                const drawJiRatios = (points) => { ctx.fillStyle = `rgba(100, 149, 237, 1)`; ctx.font = '12px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'bottom'; points.forEach((p, i) => ctx.fillText(data.jiNotes[i].label, p.x, p.y - 5)); };
                const drawHighlight = (point, alpha = 1) => { ctx.fillStyle = `rgba(0, 200, 83, ${alpha * 0.5})`; ctx.beginPath(); ctx.arc(point.x, point.y, 15, 0, 2 * Math.PI); ctx.fill(); };
                const drawComponentHighlight = (point) => { ctx.fillStyle = `rgba(255, 215, 0, 0.4)`; ctx.beginPath(); ctx.arc(point.x, point.y, 15, 0, 2 * Math.PI); ctx.fill(); };
                const drawInfoText = (text, yOffset = 0) => { ctx.fillStyle = `rgba(255, 255, 255, 1)`; ctx.font = '14px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(text, centerX, data.textY + yOffset); };

                let edoAlpha = 1.0;
                let interpolatedPoints = data.circlePositions;
                const unrollStageIndex = ANIMATION_STAGES.findIndex(s => s.name === 'UNROLL');
                const rollBackStageIndex = ANIMATION_STAGES.findIndex(s => s.name === 'ROLL_BACK');

                if (stageIndex >= unrollStageIndex) {
                    const unrollProgress = stageName === 'UNROLL' ? easedProgress : 1.0;
                    edoAlpha = 1.0 - unrollProgress;
                    interpolatedPoints = data.circlePositions.map((p, i) => ({ x: p.x + (data.linePositions[i].x - p.x) * unrollProgress, y: p.y + (data.linePositions[i].y - p.y) * unrollProgress }));
                }
                if (stageName === 'ROLL_BACK') { interpolatedPoints = data.linePositions.map((p, i) => ({ x: p.x + (data.circlePositions[i].x - p.x) * easedProgress, y: p.y + (data.circlePositions[i].y - p.y) * easedProgress })); }
                if (stageIndex > rollBackStageIndex) { interpolatedPoints = data.circlePositions; }

                ctx.globalAlpha = edoAlpha; drawMainCircle(); drawEDONotes(); ctx.globalAlpha = 1.0;
                drawBaseJiLine(interpolatedPoints); 
                drawJiRatios(interpolatedPoints);

                const highlightStages = [
                    { name: 'SHOW_ROOT', point: data.rootPoint, text: [`${baseFrequency.toFixed(1)} Hz`, "The root is the 1st harmonic."] },
                    { name: 'SHOW_OCTAVE', point: data.octavePoint, text: [`${(baseFrequency * 2).toFixed(1)} Hz`, "The 2nd harmonic is 2 times the root."] },
                    { name: 'SHOW_PERFECT_FIFTH', point: data.p5Point, text: ["The 3rd harmonic divided by 2 to keep it in the circle."] },
                    { name: 'SHOW_PERFECT_FOURTH', point: data.p4Point, text: ["The 3rd harmonic inverted and multiplied by 4 to be in the circle."] },
                    { name: 'SHOW_MAJOR_THIRD', point: data.M3Point, text: ["The 5th harmonic is divided by 4 to keep it in the circle."] },
                    { name: 'SHOW_MINOR_THIRD', point: data.m3Point, text: ["The interval between the 5th and 6th harmonics, or the 19th harmonic."] },
                    { name: 'SHOW_DERIVED_M2', point: data.M2Point, text: ["(3/2) * (3/2) = 9/8,", "or the 9th harmonic divided to be in the circle."], components: [data.p5Point] },
                    { name: 'SHOW_DERIVED_M6', point: data.M6Point, text: ["(5/4) * (4/3) = 5/3"], components: [data.M3Point, data.p4Point] },
                    { name: 'SHOW_DERIVED_m2', point: data.m2Point, text: ["(4/3) / (5/4) = 16/15"], components: [data.p4Point, data.M3Point] },
                    { name: 'SHOW_DERIVED_M7', point: data.M7Point, text: ["(5/4) * (3/2) = 15/8"], components: [data.M3Point, data.p5Point] },
                    { name: 'SHOW_DERIVED_TRITONE', point: data.tritonePoint, text: ["(15/8) * (3/2) = 45/32"], components: [data.M7Point, data.p5Point] },
                    { name: 'SHOW_DERIVED_m6', point: data.m6Point, text: ["(16/15) * (3/2) = 8/5"], components: [data.m2Point, data.p5Point] },
                    { name: 'SHOW_DERIVED_m7', point: data.m7Point, text: ["(6/5) * (3/2) = 9/5"], components: [data.m3Point, data.p5Point] }
                ];
                
                const clearHighlightsIndex = ANIMATION_STAGES.findIndex(s => s.name === 'CLEAR_HIGHLIGHTS');
                highlightStages.forEach(hs => {
                    const hsIndex = ANIMATION_STAGES.findIndex(s => s.name === hs.name);
                    if (stageIndex >= hsIndex && stageIndex < clearHighlightsIndex) { drawHighlight(hs.point, 1.0); }
                    if (stageName === hs.name) {
                        hs.text.forEach((line, i) => drawInfoText(line, i * 20));
                        if(hs.components) { hs.components.forEach(comp => drawComponentHighlight(comp)); }
                    }
                });

                if (stageName === 'SHOW_THIRD_HARMONIC') {
                    const thirdHarmonicX = data.lineStartX + (data.lineLength * (Math.log2(3) / Math.log2(2)));
                    ctx.strokeStyle = 'rgba(255, 100, 100, 0.7)'; ctx.lineWidth = 2; ctx.beginPath();
                    ctx.moveTo(data.octavePoint.x, data.octavePoint.y); ctx.lineTo(data.octavePoint.x + (thirdHarmonicX - data.octavePoint.x) * easedProgress, data.octavePoint.y); ctx.stroke();
                    drawInfoText(`${(baseFrequency * 3).toFixed(1)} Hz`); drawInfoText("The 3rd harmonic is 3 times the root.", 20);
                } else if (stageName === 'SHOW_FOURTH_HARMONIC') {
                    drawHighlight(data.octavePoint, easedProgress);
                    drawInfoText("The 4th harmonic is 2 times the 2nd harmonic.", 20);
                } else if (stageName === 'CLEAR_HIGHLIGHTS') {
                    const highlightAlpha = 1.0 - easedProgress;
                    highlightStages.forEach(hs => drawHighlight(hs.point, highlightAlpha));
                } else if (stageName === 'FADE_IN_EDO') {
                    ctx.globalAlpha = easedProgress; drawMainCircle(); drawEDONotes(); ctx.globalAlpha = 1.0;
                }
            }

            // --- Event Handlers ---
            playModeBtn.addEventListener('click', togglePlayMode); playChordBtn.addEventListener('click', playChord); playScaleBtn.addEventListener('click', playScale);
            volumeSlider.addEventListener('input', (e) => { masterVolume = parseFloat(e.target.value); if (masterGainNode) { masterGainNode.gain.setValueAtTime(masterVolume, audioContext.currentTime); }});
            draw32Btn.addEventListener('click', () => {
                let startPoint, startAngle;
                if (jiPath.length === 0) { if (currentNoteIndex === null) return; const startNote = edoNotes[currentNoteIndex]; startPoint = { x: startNote.x, y: startNote.y }; startAngle = startNote.angle; jiPath = [startPoint]; path = []; rootNoteIndex = currentNoteIndex = null; } 
                else { startPoint = jiPath[jiPath.length - 1]; startAngle = Math.atan2(startPoint.y - centerY, startPoint.x - centerX); }
                const endAngle = startAngle + JI_PERFECT_FIFTH_RADIANS; const endX = centerX + circleRadius * Math.cos(endAngle); const endY = centerY + circleRadius * Math.sin(endAngle);
                jiPath.push({ x: endX, y: endY }); updateControls(); draw();
            });
            edoInput.addEventListener('change', () => setup()); baseFreqInput.addEventListener('change', () => setup());
            resetBtn.addEventListener('click', () => setup(true)); animateBtn.addEventListener('click', startAnimation);
            toggleRatiosBtn.addEventListener('click', () => { if(!isAnimating) { showRatios = !showRatios; if (!showRatios) showIntervalNames = false; updateControls(); draw(); }});
            toggleNamesBtn.addEventListener('click', () => { if(!isAnimating && showRatios) { showIntervalNames = !showIntervalNames; draw(); }});
            showEdoFreqsBtn.addEventListener('click', () => { if(!isAnimating) { showEdoFreqs = !showEdoFreqs; draw(); }});
            showJiFreqsBtn.addEventListener('click', () => { if(!isAnimating) { showJiFreqs = !showJiFreqs; draw(); }});
            addIntervalBtn.addEventListener('click', () => { if (currentNoteIndex === null || isAnimating) return; jiPath = []; currentNoteIndex = (currentNoteIndex + parseInt(intervalSelect.value)) % edo; path.push(currentNoteIndex); updateControls(); draw(); });
            edoZoomSlider.addEventListener('input', (e) => { edoZoom = parseFloat(e.target.value); updateAllRadii(); generateAllNotes(); draw(); });
            jiZoomSlider.addEventListener('input', (e) => { jiZoom = parseFloat(e.target.value); updateAllRadii(); generateJINotes(); draw(); });
            canvas.addEventListener('click', handleCanvasInteraction);
            canvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleCanvasInteraction(e); });
            window.addEventListener('resize', () => setup());
            setup();
        });
    </script>
</body>
</html>
